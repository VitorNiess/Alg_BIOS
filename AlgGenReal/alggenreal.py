# -*- coding: utf-8 -*-
"""AlgGenReal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-DKTLoNeePY2KWEzGOWY3c34x68Xgrp1
"""

import random
import math
import copy
import matplotlib.pyplot as plt
import sys

# Função que gera a população inicial
def genIniPop(popSize, pop):

    for i in range(popSize):
        aux = []

        for j in range(3):
            aux.append(random.uniform(-2, 2))
        pop.append(aux)

    return pop

# Calcula o fitness de cada indivíduo da geração
def calcObjFunc(popSize, pop):
    fits = []

    for i in range (popSize):

        sum1 = pop[i][0] ** 2 + pop[i][1] ** 2 + pop[i][2] ** 2

        sum2 = math.cos(2 * math.pi * pop[i][0]) + math.cos(2 * math.pi * pop[i][1]) + math.cos(2 * math.pi * pop[i][2])

        fits.append(-20 * math.exp(-0.2 * (math.sqrt(1/3 * sum1))) - math.exp(1/3 * sum2) + 20 + math.exp(1))

    return fits

# Seleciona os pais da próxima geração
def sel(popSize, fits):
    fats = []
    aux_fit = []
    roleta = []
    sum = 0

    for i in range (popSize):
        aux_fit.append (1 / fits[i])
        sum += aux_fit[i]

    for i in range (popSize):
        roleta.append(aux_fit[i] / sum)

    while len(fats) != popSize:
        r = random.uniform(0, 1)
        p = 0
        j = 0

        while True:
            p += roleta[j]
            if r <= p:
                fats.append(j)
                break

            j += 1

    return fats

# Função que faz o cruzamento BLXA
def blxa(popSize, fats, pop):
    sons = []
    alfa = 0.5

    if popSize % 2 != 0:
        size = popSize- 1
    else:
        size = popSize

    for i in range (0, size, 2):
        aux1 = []
        aux2 = []

        for j in range (3):
            d = abs(pop[fats[i]][j] - pop[fats[i + 1]][j])
            int1 = min(pop[fats[i]][j], pop[fats[i + 1]][j] + alfa * d)
            int2 = max(pop[fats[i]][j], pop[fats[i + 1]][j] + alfa * d)

            aux1.append(random.uniform(int1, int2))
            aux2.append(random.uniform(int1, int2))

        sons.append(aux1)
        sons.append(aux2)

    if popSize % 2 != 0:
        aux1 = copy.deepcopy(pop[fats[i]])
        sons.append(aux1)

    return sons

# Função que faz o cruzamento BLXAB
def blxab(popSize, fats, pop):
    sons = []
    alfa = 0.75
    beta = 0.25

    if popSize % 2 != 0:
        size = popSize - 1
    else:
        size = popSize

    for i in range(0, size, 2):
        aux1 = []
        aux2 = []

        for j in range(3):
            d = abs(pop[fats[i]][j] - pop[fats[i + 1]][j])

            if pop[fats[i]][j] - pop[fats[i + 1]][j]:
                aux1.append(random.uniform(pop[fats[i]][j] - alfa * d, pop[fats[i + 1]][j] + beta * d))
                aux2.append(random.uniform(pop[fats[i]][j] - alfa * d, pop[fats[i + 1]][j] + beta * d))
            else:
                aux1.append(random.uniform(pop[fats[i + 1]][j] - alfa * d, pop[fats[i]][j] + beta * d))
                aux2.append(random.uniform(pop[fats[i + 1]][j] - alfa * d, pop[fats[i]][j] + beta * d))

        sons.append(aux1)
        sons.append(aux2)

    if popSize % 2 != 0:
        aux1 = copy.deepcopy(pop[fats[i]])
        sons.append(aux1)

    return sons

# Função que faz a mutação
def mutate(popSize, pop, mutRate):

    for i in range(popSize):

        for j in range(3):
            r = random.uniform(0, 1)

            if r <= mutRate:
                pop[i][j] = random.uniform(-2, 2)

    return pop

# Função que seleciona o melhor indivíduo
def selBest(popSize, fits):
    menor = fits[0]
    p = 0

    for i in range(popSize -1, -1, -1):
        if fits[i] < menor:
            menor = fits[i]
            p = i

    return p

# Função que plota o gráfico
def plota(genNum):
    # Lê os arquivos e guarda eles nas variaveis 'linhas'
    with open('saida_a.txt', 'r') as arquivo:
        linhas_1 = arquivo.readlines()

    with open('saida_ab.txt', 'r') as arquivo:
        linhas_2 = arquivo.readlines()

    resultados_1 = [float(linha.strip()) for linha in linhas_1]
    resultados_2 = [float(linha.strip()) for linha in linhas_2]

    geracoes = list(range(genNum))

    # Plota o gráfico
    plt.plot(geracoes, resultados_1, label = "Cruzamento BLXA")
    plt.plot(geracoes, resultados_2, label = "Cruzamento BLXAB")
    plt.title('Algoritmo Genético')
    plt.xlabel('Gerações')
    plt.ylabel('Melhor resultado')
    plt.grid(True)
    plt.legend()
    plt.show()

# Função principal
def mainAlg(popSize, pop, genNum, mutRate, tC, t):
    arquivo =  open("saida_a.txt","w")

    sons = []
    fats = []
    fits = []

    g = 0

    while g < genNum:
        fits = calcObjFunc(popSize, pop)
        fats = sel(popSize, fits)

        r = random. uniform(0, 1)

        if r < tC:
            # Faz o cruzamento de acordo com o tipo escolhido (0 - BLXA, 1 - BLXAB)
            if t == 0:
                sons = blxa(popSize, fats, pop)
            else:
                sons = blxab(popSize, fats, pop)
        else:
            sons = copy.deepcopy(pop)

        sons = mutate(popSize, sons, mutRate)

        # Seleciona o melhor elemento da geração
        pos = selBest(popSize, fits)
        best = pop[pos]


        # Faz a cópia da nova população - 1 (espaço reservado para o elitismo)
        if r < tC:
            pop = copy.deepcopy(sons)

        # Adiciona o melhor da geração anterior na nova geração
        pop[popSize - 1] = best

        g += 1

        arquivo.write(str(fits[pos]) + "\n")

    arquivo.close()

popSize = 100 # Tamanho da geração
genNum = 100 # Número de gerações
mutRate = 0.1 # Taxa de mutação
tC = 1 # Taxa de cruzamento

pop = []
pop = genIniPop(popSize, pop)

mainAlg(popSize, pop, genNum, mutRate, tC, 1) # Último parâmetro seleciona o algoritmo a ser usaodo (0 - BLXA, 1 - BLXAB)

# Copia o conteudo pro arquivo ab
with open('saida_a.txt', 'r') as arquivo:
    conteudo = arquivo.read()

with open('saida_ab.txt', 'w') as arquivo:
    arquivo.write(conteudo)

mainAlg(popSize, pop, genNum, mutRate, tC, 0)  # Último parâmetro seleciona o algoritmo a ser usaodo (0 - BLXA, 1 - BLXAB)

plota(genNum)